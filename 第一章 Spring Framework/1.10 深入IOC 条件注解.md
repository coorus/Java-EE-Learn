# 深入IOC 条件注解
动态决定 Bean 是否生效
## `@ConditionalOnProperty`
`@ConditionalOnProperty` 注解用于根据配置文件中的属性值动态决定某个 Bean 是否生效。

- **属性解释**：
  - `value`：指定配置项的 key。
  - `havingValue`：指定配置项的值，当配置项的值与该值匹配时，Bean 生效。
  - `matchIfMissing`：如果配置项不存在，是否使 Bean 生效，默认为 `false`。

```properties
# application.properties
cpu.type=cpuA
```

```java
// Config.java
@Configuration
public class Config {

    @Bean
    //当配置cpu.type等于cpuA时，bean生效（如果配置文件中没有cpu.type也生效）
    @ConditionalOnProperty(value = "cpu.type", havingValue = "cpuA", matchIfMissing = true)
    public ICpu cpuA() {
        return new CpuA();
    }

    @Bean
    //当配置cpu.type等于cpuB时，bean生效（如果配置文件中没有cpu.type不生效）
    @ConditionalOnProperty(value = "cpu.type", havingValue = "cpuB")
    public ICpu cpuB() {
        return new CpuB();
    }
}
```

- **示例说明**：
  1. 如果 `cpu.type=cpuB`，则生成 `cpuB`。
  2. 如果 `application.properties` 中没有 `cpu.type` 的配置，则生成 `cpuA`。
  3. 如果 `cpu.type` 为空或等于 `cpuA`，则生成 `cpuA`。

#### 练习：使用 `@Component` + `@ConditionalOnProperty` 实现上述功能。

---

#### 2. `@ConditionalOnClass` / `@ConditionalOnMissingClass`
- **作用**：当项目中包含或不包含某个类时，决定 Bean 是否生效。

```java
// Config.java
@Configuration
public class Config {

    @Bean
    @ConditionalOnClass(name = "java.util.List")
    public ICpu cpuA() {
        return new CpuA();
    }
}
```

- **应用场景**：通过判断是否导入了某个数据库驱动类，生成对应的数据库连接 Bean。

---

#### 3. `@ConditionalOnBean` / `@ConditionalOnMissingBean`
- **作用**：当容器中存在或不存在指定的 Bean 时，决定另一个 Bean 是否生效。

```java
// Config.java
@Configuration
public class Config {

    @Bean
    public ICpu cpuA() {
        return new CpuA();
    }

    @Bean
    public IMemory memoryA() {
        return new MemoryA();
    }

    @Bean
    public IMemory memoryB() {
        return new MemoryB();
    }

    @Bean
    @ConditionalOnBean(name = {"cpuA", "memoryA", "memoryB"})
    public Computer computer(ICpu cpuA, List<IMemory> memory) {
        return new Computer(cpuA, memory);
    }
}
```

- **应用场景**：当容器中已经存在某些特定的 Bean 时，自动配置另一个依赖这些 Bean 的对象。